<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wordle – English & Հայերեն</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/favicon.ico">
<style>
    :root {
        --bg: #1a1a1c;
        --text: #fff;
        --tile-text-color:#fff;
        --tile-text-color-before:#fff;
        --tile-border-active: #555;
        --tile-border: #3a3a3c;
        --key-bg: #818384;

        --key-hover: #9a9a9d;
        --green:#538d4e ;
        --yellow:#b59f3b ;
        --gray: #3a3a3c;
        --greenbtn: #659e6e;
        --btnHover: #5e5e5e;
        --modal-bg: #333;
        --red: #c93b3b;

        --current-word-length: 5;
        --tile-gap: 8px;

        --fluid-size: calc((95vw - (var(--current-word-length) * var(--tile-gap))) / var(--current-word-length));
        --tile-size: min(52px, var(--fluid-size));
    } 

    body.light {
        --bg: #ffffff;
        --text: #464646;
        --tile-text-color:#fff;
        --tile-text-color-before:#534d4d;
        --tile-border-active: #999;
        --tile-border: #d3d6da;
        --key-bg: #d3d6da;

        --key-hover: #c0c0c0;
        --green:#79b851;
        --yellow:#f3c237;
        --gray: #9b9ea4;
        --greenbtn: #57ac57;
        --btnHover: #e6f3e6;
        --modal-bg: #aaa;
        --red:#e93b3b;
    }


    body.high-contrast {
        --green:#f55a00 ;
        --yellow:#323dd1 ;
        --gray: #3a3a3c;
        --red:#323dd1;
    }

    body {
        margin: 0;
        padding: 20px;
        background: var(--bg);
        color: var(--text);
        font-family: Arial, Helvetica, sans-serif;
        text-align: center;
        height: 100vh;
        display: flex;
        flex-direction: column;
    }

    body.light .modal-content {
        background: #f0f0f0;
        color: #000;
        border-color: #ccc;
    }

    body.light .icon-btn {
        background: #eee;
    }

    header {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        align-items: center;
        margin-left: auto;
        margin-right: auto;
        max-width: 700px;
        gap: 40px; 
        flex-wrap: wrap;
        margin-bottom: 20px;
        padding: 10px 0;
        border-bottom: 2px solid #818384;
    }

    .header-group {
        display: flex;
        gap: 30px;
        flex: 1; 
    }

    .header-group.right {
        justify-content: flex-end;
    }

    #game-title {
        margin: 0;
        text-align: center;
        flex: 0 0 auto; /* Title only takes as much space as it needs */
    }

    @media (max-width: 530px) {
        header {
            justify-content: center;
        }

        #game-title {
            order: 2;      /* Moves title to the middle row */
            width: 100%;   /* Forces it to occupy its own line */
            margin: 10px 0;
        }

        .header-group.left {
            order: 1;      /* Top row */
            justify-content: center;
            width: 100%;
        }

        .header-group.right {
            order: 3;      /* Bottom row */
            justify-content: center;
            width: 100%;
        }
    }

    header button {
        width: 50px;
        height: 50px;
        border-radius: 10px; 
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.8s ease;
    }

    .icon-btn:hover {
        background: var(--btnHover) !important;
        transition: all 0.5s ease;
    }

    header button:hover svg{
        fill:var(--greenbtn);
        transition: all 0.5s ease;
    }

    h1 {
        margin: 0;
        font-size: 2.8em;
    }

    button, select {
        padding: 10px 16px;
        font-size: 1em;
        border: none;
        border-radius: 6px;
        background: var(--modal-bg);
        color: white;
        cursor: pointer;
    }

    button:hover { opacity: 0.9; }

    #board {
        display: grid;
        grid-template-rows: repeat(6, var(--tile-size));
        width: fit-content;
        margin-left: auto;
        margin-right: auto;

        max-width: 100vw;
        padding-left: 0;
        padding-right: 0;
        gap: var(--tile-gap);
        padding-top: 30px;
        perspective: 1000px; 
        box-sizing: border-box;
    }
    
    .row {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: var(--tile-size);
        gap: var(--tile-gap);
        justify-content: center;
    }

    .tile {
        width: var(--tile-size);
        height: var(--tile-size);
        font-size: calc(var(--tile-size) * 0.5);
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        text-transform: uppercase;
        user-select: none;
        -webkit-user-select: none;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s, border-color 0.6s, background 0.6s;
    }
    .tile.pop {
        animation: pop 0.15s ease-in-out;
    }
    @keyframes pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    .tile.flipped {
        transform: rotateX(180deg);
    }

    .tile .front, .tile .back {
        border: 2px solid var(--tile-border);
        border-radius: 6px;
        position: absolute;
        width: 100%;
        height: 100%;
        color:var(--tile-text-color-before);
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .tile .front.tileActive {
        border: 2px solid var(--tile-border-active);
    }

    .tile .back {
        color:var(--tile-text-color);
        transform: rotateX(180deg);
    }

    .green .back { background:var(--green); border-color:var(--green); }
    .yellow .back { background:var(--yellow); border-color:var(--yellow); }
    .gray .back { background:var(--gray); border-color:var(--gray); }

    .key.green{ background:var(--green) ;}
    .key.yellow{ background:var(--yellow) ;}
    .key.gray{ background:var(--gray) ;}

    .example-row {
        display: flex;
        justify-content: center;
        gap: 5px;
        margin: 20px 0;
    }

    .example-tile {
        width: 50px;
        height: 50px;
        font-size: 1.8em;
        font-weight: bold;
    }

    #keyboard {
        padding-top: 20px;
        width: 100%;
        max-width: 600px;
        box-sizing: border-box;
        margin: 0 auto;
        padding-bottom: 20px;
        user-select: none;
        -webkit-user-select: none;
    }
    .key-row {
        display: flex;
        width: 100%;
        gap: min(1.5vw, 6px);
        justify-content: center;
        margin: 4px 0;
    }
    .key {
        background: var(--key-bg);
        color:var(--tile-text-color-before);
        flex: 1;
        min-width: 0;
        padding: 15px 0;
        border-radius: 6px;
        text-align: center;
        font-weight: bold;
        cursor: pointer;
        position: relative;
        transition: background 0.6s, color 0.6s;
    }
    
    .keyGreen {
        color:var(--tile-text-color) !important;
        background: var(--green) !important;
    }

    .keyYellow {
        color:var(--tile-text-color) !important;
        background: var(--yellow) !important;
    }

    .keyGray {
        color:var(--tile-text-color) !important;
        background: var(--gray) !important;
    }

    .key:hover { 
        background: var(--btnHover); 
        color: var(--greenbtn)
    }
    .key.large { flex: 1.5; }
    .key sup {
        position: absolute;
        top: 2px;
        right: 3px;
        font-size: 0.65em;
        opacity: 0.9;
    }

    /* Modal */
    .modal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        align-items: center;
        justify-content: center;
        z-index: 100;
    }
    .modal-content {
        background: #1e1e1e;
        padding: 30px;
        border-radius: 12px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        border: 0.5px solid #444444; 
    }
    .modal-content select {
        width: 100%;
        padding: 12px;
        margin: 15px 0;
        font-size: 1.1em;
    }
    .close-btn {
        background: var(--red);
    }

    .apply-btn {
        background: var(--green);
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
        margin-left: 15px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: var(--modal-bg);
        min-width:60px;
        transition: .4s;
        border-radius: 34px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: var(--green);
    }

    icon-btn:hover svg{
        fill: #53825a;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    .slider.round {
        border-radius: 34px;
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
        20%, 40%, 60%, 80% { transform: translateX(8px); }
    }

    .row.shake {
        animation: shake 0.6s ease-in-out;
    }

    .message-popup {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        padding: 16px 32px;
        border-radius: 8px;
        font-size: 1em;
        font-weight: bold;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s, transform 0.3s;
        z-index: 200;
    }

    .message-popup.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
    }

    .icon-btn {
        background: none;
        color:var(--text);
        border: none;
        cursor: pointer;
        padding: 10px;
        border-radius: 10px;
        transition: all 0.3s ease;
    }

    .length-square {
        width: 50px;
        height: 50px;
        background: var(--modal-bg);
        color: white;
        font-size: 1.4em;
        font-weight: bold;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid var(--tile-border-active);
    }

    .length-square:hover {
        transform: scale(1.1);
    }

    .length-square.selected {
        background: var(--green);
        border-color: var(--green);
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(83, 141, 78, 0.6);
    }

    .settingsItem {
        margin: 25px 0;
        display: flex; 
        align-items: center; 
        justify-content: space-between;
        text-align:left;
    }

    .bottomButtons {
        padding-top:20px;
        gap:10px;
        display:none;
        margin: 0 auto;
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .is-visible {
        display: flex;
    }

    .is-active {
        opacity: 1;
        transform: scale(1);
    }

    .apply-btn :disabled {
        background: #aaa;
    }

</style>
</head>
<body>

    <header>
        <div class="header-group left">
            <button id="help-btn" class="icon-btn">
                <svg viewBox="0 0 24 24" fill="gray"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
            </button>
            <button id="settings-btn" class="icon-btn">
                <svg viewBox="0 0 24 24" fill="gray"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.49.49 0 0 0-.5-.47h-3.84a.49.49 0 0 0-.5.47l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22l-1.92 3.32c-.12.22-.07.47.12.61l2.03 1.58c-.05.3-.07.62-.07.94 0 .32.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.32.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.5.41h3.84c.26 0 .45-.17.5-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.1.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.03-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
            </button>
        </div>

        <h1 id="game-title" data-i18n="title">Wordle</h1>

        <div class="header-group right">
            <button id="custom-word-btn" class="icon-btn" title="Create Custom Word">
                <svg viewBox="0 0 24 24" fill="gray">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
            </button>
            <button id="restart-btn" class="icon-btn">
                <svg viewBox="0 0 24 24" fill="gray"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
            </button>
        </div>
    </header>

<div id="message-popup" class="message-popup">
    <span id="message-text"></span>
</div>

<div id="board"></div>

<div class="bottomButtons" id="bottom-btn">
    <div >
        <button onClick="handleGameOver()" class="icon-btn" style="min-height:45px;">
            <b><span data-i18n="giveUp"></span></b>
        </button>
    </div>

    <div style="witdh:90px;">
        <button onClick="handleHintClick()" class="icon-btn" style="min-height:45px;display: inline-flex;justify-content: center;gap: 5px;" id="get-hint-btn">
            <svg width="20" height="20" stroke="var(--text)" viewBox="0 0 24 24" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M3 12h1m8 -9v1m8 8h1m-15.4 -6.4l.7 .7m12.1 -.7l-.7 .7"></path>
                <path d="M9 16a5 5 0 1 1 6 0a3.5 3.5 0 0 0 -1 3a2 2 0 0 1 -4 0a3.5 3.5 0 0 0 -1 -3">
                </path><path d="M9.7 17l4.6 0"></path>
                <b><span data-i18n="getHint"></span></b>
            </svg>
        </button>
    </div>
</div>

<div class="modal" id="hint-modal">
    <div class="modal-content">
        <h2 data-i18n="hintTitle" style="margin-top:0; color:var(--text)"></h2>
        <div id="hint-word"></div>
        <div id="show-hint-btn">
            <b><button style="margin-top:30px" class="apply-btn" id="show-hint" data-i18n="showHint"></button></b>
        </div>
    </div>
</div>

</div>

<div id="keyboard"></div>


<div class="modal" id="help-modal">
    <div class="modal-content">
        <h2 data-i18n="howToPlay" style="margin-top:0px">How to Play</h2>
        <p data-i18n="guessTheWord"></p>
        <p data-i18n="validWord"></p>
        <p data-i18n="colorsExplain"></p>

        <div class="example-row" id="example1"></div>
        <p id="explanation-text-1"></p>

        <div class="example-row" id="example2"></div>
        <p id="explanation-text-2"></p>

        <div class="example-row" id="example3"></div>
        <p id="explanation-text-3"></p>

        <p style="text-align:center; margin-top:30px;"><strong data-i18n="newWord"></strong></p>

        <div style="text-align:center; margin-top:30px;">
            <button id="close-help" data-i18n="close">Close</button>
        </div>
    </div>
</div>

<div class="modal" id="settings-modal">
    <div class="modal-content">
        <h2 data-i18n="settings" style="margin-top:0px;">Settings</h2>
        <div style="display:flex; justify-content: space-between;align-items: center;">
        <p data-i18n="chooseLanguage">Choose language:</p>
        <select id="lang-select" style="max-width:40%">
            <option value="en">English</option>
            <option value="hy">Հայերեն (Armenian)</option>
        </select>
        </div>

        <div style="margin: 25px 0; text-align: center;">
            <p data-i18n="wordLength">Word Length:</p>
            <div id="length-selector" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
            </div>
        </div>

        <div class="settingsItem" style="margin-top: 35px;">
            <span data-i18n="easyMode" style="max-width:80%;"></span>
            <label class="switch">
                <input type="checkbox" id="easy-switch">
                <span class="slider round"></span>
            </label>
        </div>

        <div class="settingsItem">
            <span data-i18n="settingsHint" style="max-width:80%;"></span>
            <label class="switch">
                <input type="checkbox" id="hints-switch">
                <span class="slider round"></span>
            </label>
        </div>

        <div class="settingsItem">
            <span data-i18n="lightmode" style="max-width:80%;"></span>
        
            <label class="switch">
                <input type="checkbox" id="light-switch">
                <span class="slider round"></span>
            </label>
        </div>

        <div class="settingsItem">
            <span data-i18n="highcontrast" style="max-width:80%;"></span>
            <label class="switch">
                <input type="checkbox" id="highcontrast-switch">
                <span class="slider round"></span>
            </label>
        </div>

        <div style="margin-top:20px">
            <button class="apply-btn" id="apply-settings" data-i18n="apply">Apply</button>
            <button class="close-btn" id="cancel-settings" data-i18n="cancel">Cancel</button>
        </div>
    </div>
</div>

<script>

    // ==== KEYBOARD LAYOUTS ====
    const layouts = {
        en: [
            ['Q','W','E','R','T','Y','U','I','O','P'],
            ['A','S','D','F','G','H','J','K','L'],
            ['DEL','Z','X','C','V','B','N','M','ENTER']
        ],
        hy: [
            ['Ա','Բ','Գ','Դ','Ե','Զ','Է','Ը','Թ','Ժ','Ի','Լ','Խ'],
            ['Ծ','Կ','Հ','Ձ','Ղ','Ճ','Մ','Յ','Ն','Շ','Ո','Չ','Պ'],
            ['ENTER','Ջ','Ռ','Ս','Վ','Տ','Ր','Ց','Ո','Ւ','DEL'],
            ['Փ','Ք','Օ','Ֆ']
        ]
    };

    const translations = {
        en: {
            title: "Wordle",
            settings: "Settings",
            howToPlay: "How to Play",
            guessTheWord: "Guess the word in 6 tries.",
            validWord: "Each guess must be a valid 5-letter word. Press Enter to submit.",
            colorsExplain: "After each guess, the tile colors will show how close you were:",
            close: "Close",
            chooseLanguage: "Choose language:",
            easyMode: "Easy Mode (any word allowed)",
            apply: "Apply",
            cancel: "Cancel",
            notInList: "Not in word list",
            brilliant: "Brilliant!",
            gameOver: "Game over! The word was",
            exampleWords: ["WEARY", "PILLS", "VAGUE"],
            exampleLetters: ["W", "I", "U"],
            correctSpot: "is in the word and in the correct spot.",
            wrongSpot: "is in the word but in the wrong spot.",
            newWord: "A new word every time you restart!",
            notInWord: "is not in the word.",
            enterCustomWord: "Enter a 4 to 5 letter word for others to guess:",
            customWordSet: "Custom word set!",
            invalidWord: "Word's format is wrong",
            settingsHint: "Show letter hints, if letter repeats",
            highcontrast: "Enable color blind (high contrast) mode",
            wordLength: "Number of letters",
            letterCountErr: "Unable to change letter count to ",
            giveUp: "Give Up",
            getHint: "Get Hint",
            hintTitle: "Hint",
            showHint: "Show Hint",
            lightmode: "Enable light mode"
        },
        hy: {
            title: "Բառդլ",
            settings: "Կարգավորումներ",
            howToPlay: "Ինչպե՞ս խաղալ",
            guessTheWord: "Գուշակիր բառը 6 փորձով։",
            validWord: "Յուրաքանչյուր գուշակություն պետք է լինի վավեր 5-տառ բառ։ Սեղմիր Enter՝ ուղարկելու համար։",
            colorsExplain: "Յուրաքանչյուր գուշակությունից հետո սալիկների գույները ցույց կտան, թե որքան մոտ ես։",
            close: "Փակել",
            chooseLanguage: "Ընտրիր լեզուն՝",
            easyMode: "Հեշտ ռեժիմ (ցանկացած բառ ընդունելի է)",
            apply: "Կիրառել",
            cancel: "Չեղարկել",
            notInList: "Չկա բառացանկում",
            brilliant: "Հրաշալի!",
            gameOver: "Ավարտվեց! Բառը՝",
            exampleWords: ["ՃԱԿԱՏ", "ԿԻԹԱՌ", "ՈՒՂԻՂ"],
            exampleLetters: ["Ճ", "Ի", "Ի"],
            correctSpot: "տառը կա բառի մեջ եւ ճիշտ տեղում է",
            wrongSpot: "տառը կա բառի մեջ, բայց սխալ տեղում է",
            notInWord: "տառը բառի մեջ չկա",
            newWord: "Նորից սկսելիս ամեն անգամ  նոր բառ!",
            enterCustomWord: "Մուտքագրիր 4-ից 10 տառանի բառ, որ ուրիշները գուշակեն:",
            customWordSet: "Պատվերով բառը սահմանվեց!",
            invalidWord: "Սխալ ձեւաչափով բառ",
            settingsHint: "Ցուցադրել հուշում, եթե տվյալ տառը կրկնվում է",
            highcontrast: "Միացնել գունակույր եղանակը",
            wordLength: "Տառերի քանակ",
            letterCountErr: "Հնարավոր չէ փոխել տառերի քանակը` ",
            giveUp: "Հանձնվել",
            getHint: "Հուշում",
            hintTitle: "Հուշում",
            showHint: "Ցուցադրել",
            lightmode: "Լուսավոր գունային եղանակ"
        }
    };

    let lang = 'en';
    let target = '';
    let targetLetterCount = 5;
    let currentGuess = '';
    let currentGuessFull = '';       // full last word string used for hint
    let row = 0;
    let previousLength = 0;
    let gameOver = false;
    let counts = {};
    let easyMode = false;
    let letterHintsOn = false;
    let isAnimating = false;
    let keyboardState = {};

    let lightTheme = false;
    let highContrast = false;

    let words = {}    // Allowed guess lists
    let answers = []  // Answers array


    lightTheme = localStorage.getItem('lightTheme') === 'true';
    highContrast = localStorage.getItem('highContrast') === 'true';
    easyMode = localStorage.getItem('easyMode') === 'true' || false;
    lang = localStorage.getItem('lang') || 'en';
    letterHintsOn = localStorage.getItem('letterHintsOn') === 'true';

    document.body.classList.toggle('light', lightTheme);
    document.body.classList.toggle('high-contrast', highContrast);


    function t(key) {
        return translations[lang][key] || key;
    }

    function updateTexts() {
        // Regular translations
        document.querySelectorAll('[data-i18n]').forEach(el => {
            el.textContent = t(el.dataset.i18n);
        });

        document.title = t('title') + ' – English & Հայերեն';
    }

    // ============================= GAME HELP ================================

    // ========================================================================

    function updateHelpExamples() {
        const ex1 = document.getElementById('example1');
        if (!ex1) return;

        const words = translations[lang].exampleWords || ["WEARY", "PILLS", "VAGUE"];
        const letters = translations[lang].exampleLetters || ["W", "I", "U"];

        ex1.innerHTML = createExampleRow(words[0], 0);
        document.getElementById('example2').innerHTML = createExampleRow(words[1], 1);
        document.getElementById('example3').innerHTML = createExampleRow(words[2], 3);

        const setExplanation = (num, letter, key) => {
            const p = document.getElementById(`explanation-text-${num}`);
            if (!p) return;
            if (lang === 'en') {
                p.innerHTML = `The letter <strong>${letter}</strong> ${t(key)}`;
            } else {
                p.innerHTML = `<strong>${letter}</strong> ${t(key)}`;
            }
            p.style.display = 'block';
        };

        setExplanation(1, letters[0], 'correctSpot');
        setExplanation(2, letters[1], 'wrongSpot');
        setExplanation(3, letters[2], 'notInWord');

        // Trigger flip animation after DOM update
        requestAnimationFrame(() => {
            const highlightedTiles = document.querySelectorAll('#example1 .green, #example2 .yellow, #example3 .gray');
            highlightedTiles.forEach((tile, index) => {
                setTimeout(() => {
                    tile.classList.add('flipped');
                }, index * 250); 
            });
        });
    }

    function createExampleRow(word, highlightIndex) {
        return word.split('').map((letter, i) => {
            const isHighlighted = i === highlightIndex;
            const colorClass = isHighlighted
                ? (highlightIndex === 0 ? 'green' : highlightIndex === 1 ? 'yellow' : 'gray')
                : '';

            if (isHighlighted) {
                return `
                <div class="tile example-tile ${colorClass}">
                    <div class="front"></div>
                    <div class="back" style="color:white; font-weight:bold;">${letter}</div>
                </div>
            `;
            } else {
                return `
                <div class="tile example-tile">
                    <div class="front">${letter}</div>
                    <div class="back"></div>
                </div>
            `;
            }
        }).join('');
    }


    // ============================== CORE UI =================================

    // ========================================================================

    function getKeyElement(letter) {
        return Array.from(document.querySelectorAll('.key')).find(el =>
            el.textContent.trim().toLowerCase() === letter.toLowerCase() || el.textContent.startsWith(letter)
        );
    }

    function showMessage(text) {
        const popup = document.getElementById('message-popup');
        const textEl = document.getElementById('message-text');
        textEl.textContent = text;
        popup.classList.add('show');

        setTimeout(() => {
            popup.classList.remove('show');
        }, 2000);
    }

    function buildBoard() {
        const board = document.getElementById('board');
        board.innerHTML = ''; 

        for (let i = 0; i < 6; i++) {
            const r = document.createElement('div');
            r.className = 'row';
            // TODO Wrap the following to a function so it reusable
            for (let j = 0; j < targetLetterCount; j++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.innerHTML = `
                <div class="front"></div>
                <div class="back"></div>
            `;
                tile.dataset.row = i;
                tile.dataset.col = j;
                r.appendChild(tile);
            }
            document.documentElement.style.setProperty('--current-word-length', targetLetterCount);
            board.appendChild(r);
        }
    }
    function buildKeyboard() {
        const kb = document.getElementById('keyboard');
        kb.innerHTML = '';
        layouts[lang].forEach(row => {
            const keyRow = document.createElement('div');
            keyRow.className = 'key-row';
            row.forEach(k => {
                const key = document.createElement('div');
                key.className = 'key';
                if (k === 'ENTER' || k === 'DEL') key.classList.add('large');
                key.textContent = k === 'DEL' ? 'DEL' : k;
                if (k !== 'ENTER' && k !== 'DEL') {
                    const sup = document.createElement('sup');
                    sup.id = `sup-${k.toLowerCase()}`;
                    key.appendChild(sup);
                }
                key.onclick = () => {
                    if (!isAnimating && !gameOver) handleKey(k);
                };
                keyRow.appendChild(key);
            });
            kb.appendChild(keyRow);
        });
    }

    function updateRow(isDeleted = false) {
        const currentLength = currentGuess.length;

        for (let i = 0; i < targetLetterCount; i++) {
            const tile = document.querySelectorAll('.row')[row].children[i];
            const front = tile.querySelector('.front');
            const letter = currentGuess[i] || '';

            front.textContent = letter;
            tile.classList.remove('pop', 'tileActive');
            void tile.offsetWidth;

            if (i === currentLength - 1 && letter && !isDeleted) {
                tile.classList.add('pop');
            } else if (i === currentLength && previousLength > currentLength) {
                if (i === previousLength - 1) {
                    tile.classList.add('pop');
                    front.classList.remove('tileActive');
                }
            }

            if (letter) {
                front.classList.add('tileActive');
            }
        }
        previousLength = currentLength;
    }

    function handleKey(k) {
        if (gameOver || isAnimating) return;

        if (k === 'ENTER') {
            if (currentGuess.length === targetLetterCount) submit();
        } else if (k === 'DELETE') {
            currentGuess = currentGuess.slice(0, -1);
            updateRow(true);
        } else if (currentGuess.length < targetLetterCount) {
            const allowed = layouts[lang].flat().filter(x => x.length === 1);
            if (allowed.includes(k)) {
                currentGuess += k;
                updateRow();
            }
        }
    }


    function animateGuess(result, kbState) {
        const tiles = Array.from(document.querySelectorAll('.row')[row].children);
        tiles.forEach((tile, i) => {
            let letter = currentGuess[i];
            isAnimating = true;

            setTimeout(() => {
                tile.classList.add('flipped');

                let colorClass = 'gray';
                if (result[i] == "GREEN") {
                    colorClass = 'green';
                } else if (result[i] == "YELLOW") {
                    colorClass = 'yellow';
                }

                tile.classList.add(colorClass);
                tile.querySelector('.back').textContent = letter;
            }, i * 300);
        });

        setTimeout(() => {
            updateKeyboard(kbState);
        }, 1200);
    }

    function updateKeyboard(state) {
        for (let i=0; i < currentGuess.length; i++) {
            let letter = currentGuess[i];
            const keyEl = getKeyElement(letter);

            keyEl.classList.remove('keyYellow', 'keyGray');

            if (state[letter] === "GREEN") {
                keyEl.classList.add("keyGreen");

            } else if (state[letter] === "YELLOW") {
                keyEl.classList.add("keyYellow");

            } else {
                keyEl.classList.add("keyGray");

            }
        }
    }

    function updateSuperscripts(counts) {
        Object.keys(counts).forEach(l => {
            const sup = document.getElementById(`sup-${l}`);
            if (sup) sup.textContent = counts[l];
        });
    }

    function buildLengthSelector() {
        const container = document.getElementById('length-selector');
        container.innerHTML = '';

        for (let len = 4; len <= 10; len++) {
            const square = document.createElement('div');
            square.textContent = len;
            square.className = 'length-square';
            if (len === targetLetterCount) {
                square.classList.add('selected');
            }
            square.onclick = () => {
                targetLetterCount = len;
                document.querySelectorAll('.length-square').forEach(s => s.classList.remove('selected'));
                square.classList.add('selected');
                getWordList(targetLetterCount).then(() => { newGame()});
            };
            container.appendChild(square);
        }
    }
    
    // =============== Definitely not neccessary UI helpers ================

    // Smooth show
    function showElement(el) {
        el.classList.add('is-visible');
        el.offsetHeight; // Force reflow
        el.classList.add('is-active');
    }

    // Smooth hide
    function hideElement(el) {
        if (el.classList.contains("is-active")) {
            el.classList.remove('is-active');
            el.addEventListener('transitionend', function callback() {
                el.classList.remove('is-visible');
            }, { once: true });

        }
    }



    // =========================== Game Logic ===============================

    function frequencyMap(word) {
        let result = {};
        for (c of word) {
            if (result[c]) { 
                result[c] = result[c] + 1 
            } else { result[c] = 1}
        }
        return result;
    }


    const buttons = document.getElementById("bottom-btn");
    const getHint = document.getElementById("get-hint-btn");
    const showHint = document.getElementById("show-hint");
    const hintModal = document.getElementById("hint-modal");
    const modalCont = hintModal.children[0];
    const hintWordCont = document.getElementById("hint-word");

    // TODO gameOver modal should be shown 
    function handleGameOver(win) {
        gameOver = true;
        hideElement(buttons);
        if (win) {
            showMessage(t('brilliant'))

        } else {
            showMessage(`${t('gameOver')} ${target}`)
        }
        //buttons.style.display = 'none';
    }

    // TODO used for answer coloring (shouldnt be global) 
    let result = [];
    let totalResult = [];

    function handleHintClick() {
        modalCont.style.maxWidth = 'min-content';

        hintWordCont.innerHTML = '';
        // Draws the last guessed word in modal
        const r = document.createElement('div');
        r.className = 'row';
        // TODO Wrap the following to a function so it reusable
        for (let j = 0; j < targetLetterCount; j++) {
            let letter = currentGuessFull[j];
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.classList.add('flipped');
            tile.innerHTML = `
                <div class="front"></div>
                <div class="back"></div>
            `;
            tile.dataset.col = j;
                
            let colorClass = 'gray';
            if (result[j] == "GREEN") {
                colorClass = 'green';
            } else if (result[j] == "YELLOW") {
                colorClass = 'yellow';
            }
 
            tile.classList.add(colorClass);
            tile.querySelector('.back').textContent = letter;

            r.appendChild(tile);
        }
        hintWordCont.appendChild(r);

        const validIndices = totalResult.map((val, index) => 
            val !== 'GREEN' ? index : null).filter(val => val !== null);
        let randomIndex = Math.floor(Math.random() * validIndices.length); 
        let hintIndex = validIndices[randomIndex];

        let hintTile = Array.from(r.children).find(el => 
            el.dataset.col == `${hintIndex}`);
        let hintLetter = target[hintIndex];

        console.log(hintTile, hintIndex, validIndices);
        
        showHint.onclick = () => {
            console.log("click");
            hintTile.classList.remove('flipped','gray','yellow');
            hintTile.querySelector('.front').textContent = hintLetter;
            hintTile.querySelector('.back').textContent = '';
            hintTile.querySelector('.front').classList.add('tileActive');
            setTimeout(() => {
                hintTile.classList.add('flipped', 'green');
                hintTile.querySelector('.back').textContent = hintLetter;
            }, 150);
        };
        hintModal.style.display ='flex';
    }

    hintModal.onclick = (e) => {
        if (e.target === hintModal) hintModal.style.display = 'none';
    };

    // TODO
    // Add hint functionality
    // Separate UI flow from the backend
    function submit() {
        currentGuess = currentGuess.toLowerCase();
        target = target.toLowerCase();
        currentGuessFull = currentGuess;

        if (!easyMode) {
            if (!words[lang].includes(currentGuess)) {
                // TODO transfer following to separate UI function
                const currentRowEl = document.querySelectorAll('.row')[row];
                currentRowEl.classList.add('shake');

                isAnimating = true;

                setTimeout(() => {
                    currentRowEl.classList.remove('shake');
                    isAnimating = false;
                }, 600);

                showMessage(t('notInList'));
                return;
            }
        }
        
        showElement(buttons);

        result = [];
        for (let i = 0; i < targetLetterCount; i++) {
            result.push(null);
        }

        let bagTarget = frequencyMap(target);
        let bagGuess  = frequencyMap(currentGuess);

        if (letterHintsOn) {
            let repeated = {};
            for (let i=0; i < targetLetterCount; i++) {
                let letter = target[i];
                let nTarget = bagTarget[letter];
                if (nTarget > 1 && bagGuess[letter] < nTarget) {
                    repeated[letter] = nTarget;
                }
                //TODO why this causes the keyEl to undefined if uncommented, when coloring the keyboard keys
                //updateSuperscripts(repeated);
            }
        }
    
        // Iteration 1 - check for correct letters
        // TODO consideer using interger states for keyboard and chose the one 
        // with higer priority this works for now

        for (let i = 0; i<target.length; i++) {
            let letter = target[i];
            if (target[i] == currentGuess[i]) {
                result[i] = "GREEN";
                keyboardState[letter] = "GREEN";
                bagTarget[letter]--;
            }
        }

        // Iteration 2 checks for yellow letters
        for (let i = 0; i<target.length; i++) {
            let letter = currentGuess[i];
            if (result[i]) continue;
            
            if (bagTarget[letter] > 0) {
                result[i] = "YELLOW";
                bagTarget[letter]--;
                if (keyboardState[letter] !== "GREEN") {
                    keyboardState[letter] = "YELLOW"
                }

            } else {
                if (keyboardState[letter] !== "YELLOW" &&
                    keyboardState[letter] !== "GREEN") {
                    keyboardState[letter] = "GRAY";
                }
                result[i] = "GRAY";
            }
        }
        
        // For hints
        totalResult = totalResult.length === 0 
            ? [...result] 
            : totalResult.map((val, i) => result[i] === 'GREEN' ? 'GREEN' : val);

        // Animation to show guess
        animateGuess(result, keyboardState);

        console.log(result);
        console.log(keyboardState);

        // Hide the hint buttons immediately, no animation delay
        if (currentGuess == target || (currentGuess !== target && row === 5)) {
            hideElement(buttons);
        }

        
        // TODO update the superscript 
        // Give the result to the Flip animation and do it   
        // Color each letter in keyboard accordingly
        
        // -----------------------------------------

        //TODO Consider using async funcion for animation and using .then for this
        setTimeout(() => {
            if (currentGuess === target) {
                handleGameOver(true);
            } else {
                row++;           // ***
                currentGuess = '';
                if (row === 6) {
                    handleGameOver(false);
                }
            }
            isAnimating = false;
        }, 5 * 450);
    }


    function handleGameOverClick() {
        //TODO open custom modal to show additioal info about the game
        if (gameOver) showMessage(`${t('gameOver')} ${target}`)
    }

    //TODO new bug restarting while the animation is on puts the row++ 
    // most likely is caused by the timeout functions (line marked *** most likely)
    function newGame() {
        target = answers[Math.floor(Math.random() * answers.length)];
        console.log("New game, word changed!!, DEBUG: Tatget -", target);
        currentGuess = '';
        hideElement(buttons);
        row = 0;
        gameOver = false;
        counts = {};
        keyboardState={};
        updateTexts();
        buildBoard();
        buildKeyboard();
        updateRow(); 
    }

    // Physical keyboard
    document.addEventListener('keydown', e => {
        if (gameOver) return;
        const k = e.key.toUpperCase();
        if (k === 'ENTER') handleKey('ENTER');
        else if (k === 'BACKSPACE') handleKey('DELETE');
        else if (k.length === 1 && /[A-ZԱ-Ֆ]/.test(k)) {
            const allowed = layouts[lang].flat().filter(x => x.length === 1);
            if (allowed.includes(k)) handleKey(k);
        }
    });

    document.body.addEventListener('click', handleGameOverClick);

    const helpModal = document.getElementById('help-modal');

    document.getElementById('help-btn').onclick = () => {
        helpModal.style.display = 'flex';
        updateHelpExamples();  
        updateTexts();
    };

    document.getElementById('close-help').onclick = () => {
        helpModal.style.display = 'none';
    };

    helpModal.onclick = (e) => {
        if (e.target === helpModal) {
            helpModal.style.display = 'none';
        }
    };

    // Settings modal
    const modal = document.getElementById('settings-modal');
    const select = document.getElementById('lang-select');
    const easySwitch = document.getElementById('easy-switch');
    const hintsSwitch = document.getElementById('hints-switch');

    document.getElementById('settings-btn').onclick = () => {
        select.value = lang;
        easySwitch.checked = easyMode;
        hintsSwitch.checked = letterHintsOn;
        document.getElementById('light-switch').checked = lightTheme;
        document.getElementById('highcontrast-switch').checked = highContrast;
        buildLengthSelector();
        modal.style.display = 'flex';
        select.focus();
    };

    document.getElementById('apply-settings').onclick = () => {
        const newLang = select.value;
        easyMode = easySwitch.checked;
        letterHintsOn = hintsSwitch.checked;
        lightTheme = document.getElementById('light-switch').checked;
        highContrast = document.getElementById('highcontrast-switch').checked;

        document.body.classList.toggle('light', lightTheme);
        document.body.classList.toggle('high-contrast', highContrast);

        localStorage.setItem('lightTheme', lightTheme);
        localStorage.setItem('highContrast', highContrast);
        localStorage.setItem('easyMode', easyMode);
        localStorage.setItem('letterHintsOn', letterHintsOn);

        console.log("EASYMODE", easyMode);

        modal.style.display = 'none';
        if (lang !== newLang) {
            lang = newLang;
            localStorage.setItem('lang', lang);
            getWordList(targetLetterCount).then(() => { newGame()});
        }

    }

    document.getElementById('cancel-settings').onclick = () => {
        modal.style.display = 'none';
    };

    modal.onclick = (e) => {
        if (e.target === modal) modal.style.display = 'none';
    };

    document.getElementById('custom-word-btn').onclick = () => {
        const custom = prompt(t('enterCustomWord') || 'Enter a 4 to 10 letter word for others to guess:');
        if (custom && custom.length < 11 && custom.length > 3 && /^[A-ZԱ-Ֆ]+$/i.test(custom)) {

            targetLetterCount = custom.length;
            getWordList(targetLetterCount).then(response => {
                target = custom.toUpperCase();
                row = 0;
                currentGuess = '';
                gameOver = false;
                counts = {};
                keyboardState={};
                buildBoard();
                updateRow();
                buildKeyboard();
                showMessage(t('customWordSet') || 'Custom word set! Share this game.');
            });

            // Later: you can add location.hash = btoa(target) for sharing
        } else if (custom) {
            showMessage(t('invalidWord') || 'Must be exactly 5 letters!');
        }
    };

    // Restart
    document.getElementById('restart-btn').onclick = newGame;

    // Remove focus from buttons
    document.querySelectorAll('button').forEach(b => b.addEventListener('click', () => b.blur()));

    // Start game
    getWordList(targetLetterCount).then(response => {
        words = response;
        newGame();
    });

    async function getWordList(length) {
        const defWords = {
            en: ['ABOUT','APPLE','BEACH','CRANE','DREAM','EAGLE','FLAME','GRAPE','HOUSE','LEMON','MANGO','NIGHT','OCEAN','PIANO','QUEEN','RIVER','SMILE','TABLE','WATER','ZEBRA'],
            hy: ['ՀԱՅԵՐ','ԳԻՇԵՐ','ԼՈՒՍԸ','ՀԱՅՐԸ','ՏԱՆԻՔ','ՔԱՎՈՐ','ԳՆԴԱԿ','ԲԱՐԻՔ','ՏՆԱԿՍ','ՊԱՀԱԿ','ՄԿՐԱՏ','ՀԻՄԱՐ','ԲԱՆԱԿ','ԱՂՋԻԿ','ՄԱՐՏԻԿ','ԳԵՏԱԿ','ԺՊԻՏՍ','ՄԱՅԻՍ','ՎԱՐԴԱԿ','ԲԱԺԱԿ']
        };

        const defCount = 5;

        try {
            const responseAll = await fetch(`./data/${lang}/${length}-letters.txt`);
            const responseAns = await fetch(`./data/${lang}/${length}-letters-answers.txt`);
            //const responseEn = await fetch(`./data/en/${length}-letters.txt`);

            if (!responseAll.ok) {
                words[lang] = defWords[lang];
                
            } else {
                const text = await responseAll.text();
                words[lang] = text.split('\n').filter(w => w.trim() !== "");
            }

            if (!responseAns.ok) {
                answers = words[lang];
            } else {
                const text = await responseAns.text();
                answers = text.split('\n').filter(w => w.trim() !== "");

            }

            if (!responseAll.ok && !responseAns.ok) {
                showMessage(`${t('letterCountErr')}${targetLetterCount}`);
                targetLetterCount = defCount;

                document.querySelectorAll('.length-square').forEach((s) => { 
                    s.classList.remove('selected');
                    if (s.innerHTML === `${targetLetterCount}`) {
                        s.classList.add('selected');
                    }
                });
            }

            console.log("WORDS", words, answers);

            return words;
        } catch (err) {
            console.log(`Error fetching words: ${err}`);
            return defWords;
        }
    }

</script>
</body>
</html>
